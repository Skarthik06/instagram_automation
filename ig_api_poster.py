# ig_api_poster.py
import os
import re
import requests
from dotenv import load_dotenv
from utils.config import config
from llm_quote_gen import generate_hashtags  # uses LLM helper
from typing import Optional

load_dotenv()
ACCESS_TOKEN = os.getenv("IG_ACCESS_TOKEN")
INSTAGRAM_ID = os.getenv("INSTAGRAM_BUSINESS_ID")
GRAPH_VERSION = "v24.0"

# a small emoji map to decorate captions; we'll pick a few based on keywords
_EMOJI_MAP = {
    "success": "ğŸ†",
    "dream": "âœ¨",
    "hope": "ğŸŒ…",
    "love": "â¤ï¸",
    "life": "ğŸŒ±",
    "growth": "ğŸŒ¿",
    "work": "ğŸ’¼",
    "strength": "ğŸ’ª",
    "focus": "ğŸ¯",
    "gratitude": "ğŸ™",
    "journey": "ğŸ›¤ï¸",
    "change": "ğŸ”",
    "start": "ğŸš€",
    "mindset": "ğŸ§ ",
    "brave": "ğŸ¦",
    "calm": "ğŸŒŠ",
    "sunrise": "ğŸŒ„",
    "nature": "ğŸŒ³",
    "mountain": "â›°ï¸",
}

STOPWORDS = {"the", "a", "an", "and", "or", "to", "of", "in", "for", "on", "with", "is", "are", "be", "at", "as", "that", "this", "it"}

def _extract_keywords(text: str, max_keywords: int = 6):
    """
    Light-weight keyword extractor: returns top words (by frequency/length).
    This is used to add emoji hints if LLM fails to suggest emojis.
    """
    words = re.findall(r"[A-Za-z']+", text.lower())
    freq = {}
    for w in words:
        if len(w) <= 3 or w in STOPWORDS:
            continue
        freq[w] = freq.get(w, 0) + 1
    items = sorted(freq.items(), key=lambda t: (-t[1], -len(t[0]), t[0]))
    return [w for w, _ in items][:max_keywords]

def _emoji_for_text(text: str, max_emojis: int = 2) -> str:
    """
    Return a small string of emojis matched from _EMOJI_MAP based on keywords in text.
    """
    shots = []
    low = text.lower()
    # prefer direct keyword matches
    for k, e in _EMOJI_MAP.items():
        if k in low and e not in shots:
            shots.append(e)
        if len(shots) >= max_emojis:
            break
    # fallback: use keyword extractor mapping
    if not shots:
        kws = _extract_keywords(text, max_keywords=max_emojis)
        for kw in kws:
            for k, e in _EMOJI_MAP.items():
                if k in kw and e not in shots:
                    shots.append(e)
                if len(shots) >= max_emojis:
                    break
            if len(shots) >= max_emojis:
                break
    return "".join(shots)

def build_caption(quote: str, use_llm_hashtags: bool = True, max_hashtags: int = 6) -> str:
    """
    Build final caption for Instagram post:
    - Quote in quotes
    - A short LLM caption line if desired (we expect main.py to supply caption separately),
      but to keep compatibility we'll craft a compact caption using quote and emojis + hashtags.
    - Combines fixed hashtags from config and dynamic ones generated by LLM helper.
    """
    # Quote line
    quote_line = f"â€œ{quote}â€"

    # emojis (small, relevant)
    emojis = _emoji_for_text(quote, max_emojis=2)

    # hashtags: combine LLM-generated dynamic tags + fixed tags from config
    fixed_cfg = config.get("hashtags", {}).get("fixed", [])
    fixed_tags = []
    for t in fixed_cfg:
        if not t:
            continue
        if t.startswith("#"):
            fixed_tags.append(t.lower())
        else:
            fixed_tags.append("#" + re.sub(r"[^\w]", "", t.lower()))

    dynamic_tags = []
    if use_llm_hashtags:
        try:
            dynamic_tags = generate_hashtags(quote, max_tags=max_hashtags)
        except Exception:
            dynamic_tags = []
    # ensure all are properly formatted and unique
    all_tags = []
    seen = set()
    for t in (dynamic_tags + fixed_tags):
        tt = t.lower()
        if not tt.startswith("#"):
            tt = "#" + re.sub(r"[^\w]", "", tt)
        if tt not in seen:
            seen.add(tt)
            all_tags.append(tt)
        if len(all_tags) >= max_hashtags + len(fixed_tags):
            break

    # Create caption body
    caption_lines = [quote_line]
    if emojis:
        caption_lines.append(emojis)
    if all_tags:
        caption_lines.append(" ".join(all_tags))

    caption = "\n\n".join(caption_lines)
    return caption

def _save_local_and_get_hosted_url(local_path: str) -> str:
    """
    Keep your existing GitHub raw-hosting trick. Make sure the values match your repo.
    Returns a raw.githubusercontent URL that Instagram can fetch.
    """
    GITHUB_USERNAME = "skarthik06"
    GITHUB_REPO = "instagram_automation"
    GITHUB_BRANCH = "main"
    repo_root = os.path.dirname(os.path.abspath(__file__))
    rel_path = os.path.relpath(local_path, repo_root).replace("\\", "/")
    raw_url = f"https://raw.githubusercontent.com/{GITHUB_USERNAME}/{GITHUB_REPO}/{GITHUB_BRANCH}/{rel_path}"
    return raw_url

def post_to_instagram(image_url: Optional[str] = None, caption: str = "", local_image_path: Optional[str] = None, timeout: int = 12) -> bool:
    """
    Post an image to Instagram using the Graph API (Business account).
    If local_image_path is supplied, the function will convert it to a raw.githubusercontent link.
    Returns True on success.
    """
    if not ACCESS_TOKEN or not INSTAGRAM_ID:
        print("âŒ IG_ACCESS_TOKEN or INSTAGRAM_BUSINESS_ID not set.")
        return False
    if local_image_path and not image_url:
        image_url = _save_local_and_get_hosted_url(local_image_path)
    if not image_url:
        print("âŒ No image URL provided.")
        return False

    try:
        # Step 1: create media object
        create_url = f"https://graph.facebook.com/{GRAPH_VERSION}/{INSTAGRAM_ID}/media"
        payload = {"image_url": image_url, "caption": caption, "access_token": ACCESS_TOKEN}
        r = requests.post(create_url, data=payload, timeout=timeout)
        r.raise_for_status()
        resp_json = r.json()
        media_id = resp_json.get("id")
        if not media_id:
            print("âŒ No media id returned:", resp_json)
            return False

        # Step 2: publish media
        publish_url = f"https://graph.facebook.com/{GRAPH_VERSION}/{INSTAGRAM_ID}/media_publish"
        pub = requests.post(publish_url, data={"creation_id": media_id, "access_token": ACCESS_TOKEN}, timeout=timeout)
        pub.raise_for_status()
        print("âœ… Successfully published post.")
        return True
    except Exception as e:
        print("âŒ Error posting to Instagram:", e)
        try:
            # helpful debug info
            if hasattr(e, "response"):
                print("Response:", e.response.text)
        except:
            pass
        return False

# If you run this file directly, simple smoke test
# if __name__ == "__main__":
#     test_quote = "Small steps repeated every day create remarkable change."
#     cap = build_caption(test_quote)
#     print("Caption:\n", cap)
